1.堆内存设置的越大发生GC的频率越低，但是每次GC所需时间也会随着堆内存的变大而增长，因此在配置堆内存大小时要考虑到业务并发所需的内存大小以及GC暂停所需时间是否可以达到性能要求
2.当直接提升内存大小后GC时间无法满足性能需求时可以通过调高young区大小的方式降低CG频率，同时如果发现大量对象会从young区升级到old区并且较短的时间范围内会被回收的话我们可以调大从young区升级到old区的阈值减少这些过早提升old区的情况，进一步降低FullGC的次数
3.尽量减少代码产生对象的数量，并且减少包装类型的使用尽量使用原生类型减少内存开销，对于数组尽量使用一维数组因为二维数组实际时以创建多个对象组合而来的会大量使用内存。
4.Serial GC只有单线程进行内存回收处理因此效率很低远远比其它GC方式速度慢，适用于C端
5.ParNew GC 是 Serial GC的改良版young区的GC时多线程的Old区的GC依然是单线程的因此使用ParNew GC时Full GC的时间依然比较长
6.Parrallel GC 多线程处理GC的方式，并且支持自动调节youg区和old区的大小
7.CMS GC 是GC暂停时间的一种方式，比较适合网站和堆服务器相应速度有要求的环境，但是在CG并发阶段会使用更多的CPU资源导致吞吐量下降，另外由于GC过程会导致大量空间碎片的产生因此会因为无法找到连续空间而导致非空间不足时的GC出现
8.G1 GC时CMS GC的改良解决了连续空间的问题并且可以限制GC时间，但是要注意GC的线程数量，防止发生GC线程抢占